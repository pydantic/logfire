from __future__ import annotations

from opentelemetry import context
from opentelemetry.sdk.trace import ReadableSpan, Span, SpanProcessor

from logfire._constants import (
    ATTRIBUTES_LOG_LEVEL_NAME_KEY,
    ATTRIBUTES_LOG_LEVEL_NUM_KEY,
    ATTRIBUTES_MESSAGE_KEY,
    ATTRIBUTES_MESSAGE_TEMPLATE_KEY,
    ATTRIBUTES_SPAN_TYPE_KEY,
    LEVEL_NUMBERS,
    PENDING_SPAN_NAME_SUFFIX,
)
from logfire._scrubbing import Scrubber
from logfire._utils import ReadableSpanDict, span_to_dict


class SpanProcessorWrapper(SpanProcessor):
    """Wrapper around other processors to intercept starting and ending spans with our own global logic.

    Suppresses starting/ending if the current context has a `suppress_instrumentation` value.
    Tweaks the send/receive span names generated by the ASGI middleware.
    """

    def __init__(self, processor: SpanProcessor, scrubber: Scrubber) -> None:
        self.processor = processor
        self.scrubber = scrubber

    def on_start(
        self,
        span: Span,
        parent_context: context.Context | None = None,
    ) -> None:
        if context.get_value('suppress_instrumentation'):
            return
        self.processor.on_start(span, parent_context)

    def on_end(self, span: ReadableSpan) -> None:
        if context.get_value('suppress_instrumentation'):
            return
        span_dict = span_to_dict(span)
        _tweak_asgi_span_name(span_dict)
        _tweak_http_route_messages(span_dict)
        self.scrubber.scrub_span(span_dict)
        span = ReadableSpan(**span_dict)
        self.processor.on_end(span)

    def shutdown(self) -> None:
        self.processor.shutdown()

    def force_flush(self, timeout_millis: int = 30000) -> bool:
        return self.processor.force_flush(timeout_millis)


def _tweak_asgi_span_name(span: ReadableSpanDict):
    """Make the name/message of spans generated by OTEL's ASGI middleware more useful.

    For example, a single request will typically generate two 'send' spans with the same message,
    e.g. 'GET /foo http send'. This function may add part of the ASGI event type to the name to make it more useful,
    so instead it shows e.g. 'http send response.start' and 'http send response.body'.
    """
    instrumentation_scope = span['instrumentation_scope']
    if not (instrumentation_scope and instrumentation_scope.name == 'opentelemetry.instrumentation.asgi'):
        return

    if not (name := span['name']).endswith(
        (
            ' http send',
            ' http receive',
            ' websocket send',
            ' websocket receive',
        )
    ):
        return

    attributes = span['attributes']
    typ = attributes.get('type')
    if (
        not (isinstance(typ, str) and typ.startswith(('http.', 'websocket.')))
        # No point in adding anything in this case, otherwise it'd say e.g. 'websocket send send'.
        # No other event types in https://asgi.readthedocs.io/en/latest/specs/www.html are redundant like this.
        or typ in ('websocket.send', 'websocket.receive')
    ):
        return

    # Strip the 'http.' or 'websocket.' prefix from the event type and add it to the span name.
    span['name'] = new_name = f'{name} {typ.split(".", 1)[1]}'
    if attributes.get(ATTRIBUTES_MESSAGE_KEY) == name:  # this should usually be the case
        span['attributes'] = {
            **attributes,
            ATTRIBUTES_MESSAGE_KEY: new_name,
            ATTRIBUTES_LOG_LEVEL_NAME_KEY: 'debug',
            ATTRIBUTES_LOG_LEVEL_NUM_KEY: LEVEL_NUMBERS['debug'],
        }


def _tweak_http_route_messages(span: ReadableSpanDict):
    """Change the logfire.msg attribute of certain spans from e.g. 'GET /route/{param}' to 'GET /route/actual_value'."""
    attributes = span['attributes']

    # Check that this generally looks like a span not generated by logfire methods.
    # This is intended for OTEL instrumentations of frameworks like FastAPI, but written to be general.
    if ATTRIBUTES_MESSAGE_TEMPLATE_KEY in attributes:
        return

    name = span['name']
    if attributes.get(ATTRIBUTES_SPAN_TYPE_KEY) == 'pending_span':
        non_pending_name = name[: -len(PENDING_SPAN_NAME_SUFFIX)]
    else:
        non_pending_name = name
    if non_pending_name != attributes.get(ATTRIBUTES_MESSAGE_KEY):
        return

    # Check that the current name/message has the form that we want to change.
    route = attributes.get('http.route')
    if not (route and isinstance(route, str) and non_pending_name.endswith(route)):
        return
    minus_route = non_pending_name[: -len(route)]
    method = attributes.get('http.method')
    if not isinstance(method, str):
        method_prefix = ''
    else:
        method_prefix = f'{method} '
    if minus_route not in (method_prefix, ''):
        return

    target = attributes.get('http.target')
    if not (target and isinstance(target, str)):
        return

    # Replace the template route (e.g. '/route/{param}')
    # with the actual URL path of the specific request in the message.
    # Note that the span name stays the same, i.e. it should be low cardinality,
    # similar to how we use the message template for logfire span names.
    span['attributes'] = {**attributes, ATTRIBUTES_MESSAGE_KEY: minus_route + target}
